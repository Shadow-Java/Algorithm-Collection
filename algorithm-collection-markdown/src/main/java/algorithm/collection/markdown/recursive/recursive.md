# 递归
## 如何写递归？
从当前节点出发，方法不考虑当前节点，从左右子节点从发

比求二叉树的最大深度？求解方法有dfs和递归，那么递归
```
public int maxDepth(TreeNode root){
        if(root == null) {
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth,rightDepth)+1;
    }
```


递归算法具有以下特性：

**自相似性**：递归算法通常是通过将大问题划分为更小的子问题来解决的。这些子问题与原始问题具有相同的结构，只是规模更小。通过在子问题上应用相同的算法，最终可以解决原始问题。

**递归调用**：递归算法通过在函数内部调用自身来实现。在每次递归调用中，问题的规模都会减小，直到达到基本情况（终止条件），然后逐层返回结果，最终得到整个问题的解。

**终止条件**：递归算法必须定义一个或多个终止条件，以指定递归调用何时结束。这些终止条件通常是基本问题的情况，其规模足够小，可以直接求解而不需要进一步的递归调用。

**栈的使用**：递归算法使用函数调用栈来管理递归调用的过程。每次递归调用时，当前函数的局部变量、返回地址和其他必要信息都会被压入栈中。当递归调用返回时，相应的信息从栈中弹出，控制权返回到上一层递归调用。

可能存在重复计算：某些递归算法可能会导致重复计算相同的子问题。为了避免重复计算，可以使用**记忆化技术**（如动态规划）或其他优化方法来存储已计算的结果，以便在需要时进行查找和复用。