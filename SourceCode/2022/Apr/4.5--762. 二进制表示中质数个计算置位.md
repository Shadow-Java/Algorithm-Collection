## 题目

给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。

计算置位位数 就是二进制表示中 1 的个数。

例如， 21 的二进制表示 10101 有 3 个计算置位。

#### 示例 1：

输入：left = 6, right = 10
输出：4
解释：
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。

#### 示例 2：

输入：left = 10, right = 15
输出：5
解释：
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
共计 5 个计算置位为质数的数字。

## 暴力解法

1.数字转二进制:`Integer.toString(i,2)`


```java
public static String ones(int num){//或者用32位数组倒着计算
        String str = "";
        while(num != 0){
            str = num%2+str;
            num /= 2;
        }
        return str;
    }
```

2.怎么判断字符串中1或0的个数

```java
public int ones(int num){//统计1的个数
        int ans = 0;
        while(num != 0){
            if(num%2==1){
                ans++;
            }
            num /= 2;
        }
        return ans;
    }
```

3.判断该数是一个质数

```java
private boolean isPrime(int x) {
        if (x < 2) {
            return false;
        }
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
```

## 质数优化

注意到 `right<=10^6<2^20`，因此二进制中的1的个数不会超过19，而不超过的质数只有` 2,3,5,7,11,13,17,19 `

因此可以用19位二进制数 `mask==665772=(10100010100010101100)₂`来存储这些质数，其中 mask 二进制的从低到高的第i位为1表示i是质数，为0表示i不是质数
 
设整数x的二进制中1的个数为c，若mask按位与2^c不为0，则说明c是一个质数。

假设x的二进制中1的个数为`2^3=8=(1000)₂` 则mask&8 != 0，说明是质数


```java
public int countPrimeSetBits(int left, int right) {
        int count = 0;
        for (int i = left; i <= right; i++) {
            int mask = 665772;
            if((mask & (1 << Integer.bitCount(i))) != 0){//1 << Integer.bitCount(i)表示左移多少位，比如2^3=1000
                count++;
            }
        }
        return count;
    }
```


## lowbit运算---树状数组